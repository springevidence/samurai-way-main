{"version":3,"file":"static/js/939.8b4e940b.chunk.js","mappings":"8OACA,EAA+B,gCAA/B,EAAsE,wB,mBCyCtE,EA/BkB,SAACA,GAQf,IAPA,IAAMC,EAAeC,KAAKC,KAAKH,EAAMI,gBAAkBJ,EAAMK,aAC7D,GAA0CC,EAAAA,EAAAA,UAAS,GAAnD,eAAOC,EAAP,KAAsBC,EAAtB,KACMC,GAAyBF,EAAgB,GAAKP,EAAMK,YAAc,EAClEK,EAAyBH,EAAgBP,EAAMK,YAE/CM,EAAaT,KAAKC,KAAKH,EAAMI,gBAAkBJ,EAAMY,UACrDC,EAAQ,GACLC,EAAI,EAAGA,GAAKH,EAAYG,IAC7BD,EAAME,KAAKD,GAEf,OAAO,2BACFP,EAAgB,IAAK,mBAAQS,QAAS,WACnCR,EAAiBD,EAAgB,IADf,SAEnB,SAEFM,EACII,QAAO,SAAAC,GAAC,OAAIA,GAAKT,GAAyBS,GAAKR,KAC/CS,KAAI,SAAAC,GACD,OAAO,kBAAiBJ,QAAS,WAC7BhB,EAAMqB,cAAcD,IACrBE,UAAWtB,EAAMuB,cAAgBH,EAAOI,EAAqBA,EAFzD,UAEsEJ,EAAK,OAFhEK,EAAAA,EAAAA,SAKzBxB,EAAeM,IAAkB,mBAAQS,QAAS,WAC/CR,EAAiBD,EAAgB,IADH,SAE/B,aCpCX,EAAwB,qB,UC8CxB,EApCa,SAACP,GACV,OACI,4BACI,6BACI,0BACI,SAAC,KAAD,CAAS0B,GAAI,YAAc1B,EAAM2B,KAAKC,GAAtC,UACK,gBAAKN,UAAWE,EAAaK,IAAK,GAAIC,IAAK,qBAIpD,yBACK9B,EAAM2B,KAAKI,UACN,mBAAQC,SAAUhC,EAAMiC,oBAAoBC,MAAK,SAAAN,GAAE,OAAIA,IAAM5B,EAAM2B,KAAKC,MAChEZ,QAAS,WACLhB,EAAMmC,aAAanC,EAAM2B,KAAKC,KAF1C,SAIA,cACA,mBAAQI,SAAUhC,EAAMiC,oBAAoBC,MAAK,SAAAN,GAAE,OAAIA,IAAM5B,EAAM2B,KAAKC,MAAKZ,QAAS,WACpFhB,EAAMoC,WAAWpC,EAAM2B,KAAKC,KAD9B,SAEC,iBAGX,6BACA,6BACI,yBAAM5B,EAAM2B,KAAKU,QACjB,yBAAMrC,EAAM2B,KAAKW,aAErB,6BACI,yBAAM,wBACN,yBAAM,8BCA1B,EApBc,SAACtC,GAEX,OACI,4BACI,SAAC,EAAD,CAAWqB,cAAerB,EAAMqB,cACrBjB,gBAAiBJ,EAAMI,gBACvBQ,SAAUZ,EAAMY,SAChBW,YAAavB,EAAMuB,YACnBlB,YAAaL,EAAMK,cAE7BL,EAAMuC,MAAMpB,KAAI,SAAAqB,GAAC,OAAI,SAAC,EAAD,CACMb,KAAMa,EACNL,aAAcnC,EAAMmC,aACpBC,WAAYpC,EAAMoC,WAClBH,oBAAqBjC,EAAMiC,qBAJtBO,EAAEZ,W,wCCRxC,SAASa,EACdC,GAE8B,IAD9BC,EAC8B,8GADiCD,GAE/D,GAAoB,oBAATA,EACT,MAAM,IAAIE,UAAUD,GAsDjB,IAAME,EAAgB,SAACC,GAC5B,OAAOC,MAAMC,QAAQF,GAAQA,EAAO,CAACA,IAUhC,SAASG,EAAgBC,GAC9B,IAAMC,EAAeJ,MAAMC,QAAQE,EAAmB,IAClDA,EAAmB,GACnBA,EAOJ,OA9CK,SACLE,GAEiC,IADjCT,EACiC,oIACjC,IACGS,EAAMC,OAAM,SAACP,GAAD,MAAgD,oBAATA,KACpD,CACA,IAAMQ,EAAYF,EACfjC,KAAI,SAAA2B,GAAA,MACa,oBAATA,EAAP,mBACgBA,EAAKT,MAAQ,UAD7B,aAEWS,KAEZS,KAAK,MACR,MAAM,IAAIX,UAAJ,UAAiBD,EAAjB,YAAiCW,EAAjC,OA2BRE,CACEL,EADF,kGAKOA,EAUF,SAASM,EACdN,EACAO,GAIA,IAFA,IAAMC,EAAuB,GACrBC,EAAWT,EAAXS,OACC9C,EAAI,EAAGA,EAAI8C,EAAQ9C,IAG1B6C,EAAqB5C,KAAKoC,EAAarC,GAAG+C,MAAM,KAAMH,IAExD,OAAOC,EC/GwBG,SAInBC,OAAOC,eAAe,ICNpC,IAOMC,EACe,qBAAZC,QACHA,QATAC,WACJ,WAAoBC,IAAU,eAAV,KAAAA,MAAAA,EADhB,cAAAD,EAAA,oBAEJ,WACE,OAAOE,KAAKD,UAHVD,EAAAA,GAiKC,SAASG,EACd5B,GAEA,IAII6B,EALJC,EACA,uDADmD,GAE/CC,EA7GG,CACLC,EA7CiB,EA8CjBC,OAAG,EACHC,EAAG,KACH1D,EAAG,MA0GG2D,EAAwBL,EAAxBK,oBAIJC,EAAe,EAEnB,SAASC,IAGP,IAFA,IAAIC,EAAYP,EACRb,EAAWqB,UAAXrB,OACC9C,EAAI,EAAGoE,EAAItB,EAAQ9C,EAAIoE,EAAGpE,IAAK,CACtC,IAAMqE,EAAMF,UAAUnE,GACtB,GACiB,oBAARqE,GACS,kBAARA,GAA4B,OAARA,EAC5B,CAEA,IAAIC,EAAcJ,EAAUJ,EACR,OAAhBQ,IACFJ,EAAUJ,EAAIQ,EAAc,IAAIC,SAElC,IAAMC,EAAaF,EAAYG,IAAIJ,QAChB,IAAfG,GACFN,EApID,CACLN,EA7CiB,EA8CjBC,OAAG,EACHC,EAAG,KACH1D,EAAG,MAiIGkE,EAAYI,IAAIL,EAAKH,IAErBA,EAAYM,MAET,CAEL,IAAIG,EAAiBT,EAAU9D,EACR,OAAnBuE,IACFT,EAAU9D,EAAIuE,EAAiB,IAAIC,KAErC,IAAMC,EAAgBF,EAAeF,IAAIJ,QACnB,IAAlBQ,GACFX,EAjJD,CACLN,EA7CiB,EA8CjBC,OAAG,EACHC,EAAG,KACH1D,EAAG,MA8IGuE,EAAeD,IAAIL,EAAKH,IAExBA,EAAYW,GAKlB,IAEIC,EAFEC,EAAiBb,EAcvB,GAlNe,IAwMXA,EAAUN,EACZkB,EAASZ,EAAUL,GAGnBiB,EAASlD,EAAKmB,MAAM,KAAMoB,WAC1BH,KAGFe,EAAenB,EAhNA,EAkNXG,EAAqB,SACjBiB,EAAA,QAAAA,EAAA,QAAAA,EAAkBvB,SAAlB,aAAkB,EAAYwB,eAA9B,QAAyCxB,EAE1B,MAAnBuB,GACAjB,EAAoBiB,EAAqCF,KAEzDA,EAASE,EACQ,IAAjBhB,GAAsBA,KAGxB,IAAMkB,EACe,kBAAXJ,GAAkC,OAAXA,GACb,oBAAXA,EACTrB,EAAayB,EAAe,IAAI/B,EAAI2B,GAAUA,EAGhD,OADAC,EAAelB,EAAIiB,EACZA,EAcT,OAXAb,EAASkB,WAAa,WACpBxB,EA3LK,CACLC,EA7CiB,EA8CjBC,OAAG,EACHC,EAAG,KACH1D,EAAG,MAwLH6D,EAASmB,qBAGXnB,EAASD,aAAe,kBAAMA,GAE9BC,EAASmB,kBAAoB,WAC3BpB,EAAe,GAGVC,ECzBF,SAASoB,EAUdC,GAOA,2BANGC,EAMH,iCANGA,EAMH,kBAEA,IAAMC,EAG0B,oBAArBF,EACP,CACEG,QAASH,EACTI,eAAgBH,GAElBD,EAEEK,EAAiB,WAgBlB,2BAVAvD,EAUA,yBAVAA,EAUA,gBACH,IAEIqB,EAFAmC,EAAiB,EACjBC,EAA2B,EAM3BC,EAKA,GAGAC,EAAa3D,EAAmB4D,MAUV,kBAAfD,IACTD,EAAwBC,EAExBA,EAAa3D,EAAmB4D,OAGlCrE,EACEoE,EADF,4FAEuFA,EAFvF,MAOA,IAAME,GAAkBA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAAA,GACnBT,GACAM,GAIHL,EAKEQ,EALFR,QADF,EAMIQ,EAJFP,eAAAA,OAFF,MAEmB,GAFnB,IAMIO,EAHFC,YAAAA,OAHF,MAGgB1C,EAHhB,IAMIyC,EAFFE,mBAAAA,OAJF,MAIuB,GAJvB,EAaMC,GAPFH,EADFI,cAQ0BtE,EAAc2D,IACpCY,EAA0BvE,EAAcoE,GACxC9D,EAAeF,EAAgBC,GAE/BmE,EAAqBd,EAAAA,WAAAA,EAAAA,CAAQ,WAIjC,OAHAG,IAGQG,EAAgDhD,MACtD,KACAoB,aANuB,eAQrBiC,KAMAI,EAAWN,EAAAA,WAAAA,EAAAA,CAAY,WAC3BL,IAEA,IAAMhD,EAAuBF,EAC3BN,EACA8B,WAiCF,OAFAV,EAAa8C,EAAmBxD,MAAM,KAAMF,KApC7B,eAuCXyD,KAON,OAAOrD,OAAOwD,OAAOD,EAAU,CAC7BT,WAAAA,EACAQ,mBAAAA,EACAlE,aAAAA,EACAwD,yBAA0B,kBAAMA,GAChCa,8BAA+B,WAC7Bb,EAA2B,GAE7BpC,WAAY,kBAAMA,GAClBmC,eAAgB,kBAAMA,GACtBe,oBAAqB,WACnBf,EAAiB,GAEnBH,QAAAA,EACAS,YAAAA,KAQJ,OAAOP,EAeF,IAAMA,EACKN,EAAsB7B,GCpb3BoD,EAAWjB,GAHC,SAACkB,GACtB,OAAOA,EAAMC,UAAUrF,SAE8B,SAACA,GACtD,OAAOA,EAAMtB,QAAO,SAAAuB,GAAC,OAAI,QAGhBqF,EAAc,SAACF,GACxB,OAAOA,EAAMC,UAAUhH,UAEdkH,EAAiB,SAACH,GAC3B,OAAOA,EAAMC,UAAUvH,aAEd0H,EAAqB,SAACJ,GAC/B,OAAOA,EAAMC,UAAUxH,iBAEd4H,EAAiB,SAACL,GAC3B,OAAOA,EAAMC,UAAUrG,aAEd0G,EAAgB,SAACN,GAC1B,OAAOA,EAAMC,UAAUM,YAEdC,EAAyB,SAACR,GACnC,OAAOA,EAAMC,UAAU3F,qBCoBrBmG,EAAAA,SAAAA,IAAAA,EAAAA,EAAAA,GAAAA,EAAAA,GAAAA,IAAAA,GAAAA,EAAAA,EAAAA,GAAAA,GAAAA,SAAAA,IAAAA,IAAAA,GAAAA,EAAAA,EAAAA,GAAAA,KAAAA,GAAAA,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,UAAAA,GASD,OATCA,EAAAA,EAAAA,KAAAA,MAAAA,EAAAA,CAAAA,MAAAA,OAAAA,KAMF/G,cAAgB,SAACgH,GACb,IAAOzH,EAAY,EAAKZ,MAAjBY,SACP,EAAKZ,MAAM0H,SAASW,EAAYzH,IACnC,EAqBA,OArBA,yCARD,WACI,MAAgCyD,KAAKrE,MAA9BuB,EAAP,EAAOA,YAAaX,EAApB,EAAoBA,SACpByD,KAAKrE,MAAM0H,SAASnG,EAAaX,KACpC,oBAOD,WACI,OAAO,gCACFyD,KAAKrE,MAAMkI,YACN,SAACI,EAAA,EAAD,IACA,MAEN,SAAC,EAAD,CAAOlI,gBAAiBiE,KAAKrE,MAAMI,gBAC5BiB,cAAegD,KAAKhD,cACpBkB,MAAO8B,KAAKrE,MAAMuC,MAClB3B,SAAUyD,KAAKrE,MAAMY,SACrBW,YAAa8C,KAAKrE,MAAMuB,YACxBgH,OAAQlE,KAAKrE,MAAMuI,OACnBC,SAAUnE,KAAKrE,MAAMwI,SACrBvG,oBAAqBoC,KAAKrE,MAAMiC,oBAChCE,aAAckC,KAAKrE,MAAMmC,aACzBC,WAAYiC,KAAKrE,MAAMoC,WACvB/B,YAAagE,KAAKrE,MAAMK,qBAGtC,EA9BC+H,CAAmBK,EAAAA,WAmEnBC,EAAS,CACXH,OAAQI,EAAAA,GACRH,SAAUI,EAAAA,GACVC,SAAUC,EAAAA,GACVC,eAAgBC,EAAAA,GAChBC,0BAA2BC,EAAAA,GAC3BxB,SAAUyB,EAAAA,GACVhH,aAAciH,EAAAA,GACdhH,WAAYiH,EAAAA,IAKhB,GADuBC,EAAAA,EAAAA,KA9CC,SAAC3B,GACrB,MAAO,CACHpF,MAAOmF,EAASC,GAChB/G,SAAUiH,EAAYF,GACtBvH,gBAAiB2H,EAAmBJ,GACpCpG,YAAayG,EAAeL,GAC5BO,WAAYD,EAAcN,GAC1B1F,oBAAqBkG,EAAuBR,GAC5CtH,YAAayH,EAAeH,MAsCYe,EAAzBY,CAAiClB","sources":["webpack://samurai-way/./src/components/common/Paginator/Paginator.module.css?6caa","components/common/Paginator/Paginator.tsx","webpack://samurai-way/./src/components/Users/Users.module.css?b9d0","components/Users/User.tsx","components/Users/Users.tsx","../node_modules/reselect/src/utils.ts","../node_modules/reselect/src/autotrackMemoize/proxy.ts","../node_modules/reselect/src/weakMapMemoize.ts","../node_modules/reselect/src/createSelectorCreator.ts","redux/users-selectors.ts","components/Users/UsersContainer.tsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"selectedPage\":\"Paginator_selectedPage__CRNLp\",\"page\":\"Paginator_page__FNDKJ\"};","import React, {useState} from 'react';\nimport style from \"./Paginator.module.css\";\nimport {v1} from \"uuid\";\n\ntype PaginatorPropsType = {\n    onPageChanged: (page: number) => void\n    totalItemsCount: number\n    pageSize: number\n    currentPage: number\n    portionSize: number\n}\nconst Paginator = (props: PaginatorPropsType) => {\n    const portionCount = Math.ceil(props.totalItemsCount / props.portionSize)\n    const [portionNumber, setPortionNumber] = useState(1)\n    const leftPortionPageNumber = (portionNumber - 1) * props.portionSize + 1\n    const rightPortionPageNumber = portionNumber * props.portionSize\n\n    const pagesCount = Math.ceil(props.totalItemsCount / props.pageSize)\n    const pages = []\n    for (let i = 1; i <= pagesCount; i++) {\n        pages.push(i)\n    }\n    return <div>\n        {portionNumber > 1 && <button onClick={() => {\n            setPortionNumber(portionNumber - 1)\n        }}>Prev</button>}\n\n        {pages\n            .filter(p => p >= leftPortionPageNumber && p <= rightPortionPageNumber)\n            .map(page => {\n                return <span key={v1()} onClick={() => {\n                    props.onPageChanged(page)\n                }} className={props.currentPage === page ? style.selectedPage : style.page}>{page} </span>\n            })}\n\n        {portionCount > portionNumber  && <button onClick={() => {\n            setPortionNumber(portionNumber + 1)\n        }}>Next</button>}\n    </div>\n\n};\n\nexport default Paginator;","// extracted by mini-css-extract-plugin\nexport default {\"photo\":\"Users_photo__r-B0M\"};","import React from 'react';\nimport style from \"./Users.module.css\";\nimport {UserType} from \"../../redux/store\";\nimport {NavLink} from \"react-router-dom\";\n\ntype UsersComponentPropsType = {\n    user: UserType\n    followingInProgress: number[]\n    unfollowUser: (userId: number) => void\n    followUser: (userId: number) => void\n}\nconst User = (props: UsersComponentPropsType) => {\n    return (\n        <div>\n            <span>\n                <div>\n                    <NavLink to={'/profile/' + props.user.id}>\n                         <img className={style.photo} src={''} alt={'users photo'}/>\n                    </NavLink>\n\n                </div>\n                <div>\n                    {props.user.followed\n                        ? <button disabled={props.followingInProgress.some(id => id ===props.user.id)}\n                                  onClick={() => {\n                                      props.unfollowUser(props.user.id)\n                        }\n                        }>Unfollow</button>\n                        : <button disabled={props.followingInProgress.some(id => id ===props.user.id)} onClick={() => {\n                            props.followUser(props.user.id)\n                        }}>Follow</button>}\n                </div>\n            </span>\n                <span>\n                <span>\n                    <div>{props.user.name}</div>\n                    <div>{props.user.status}</div>\n                </span>\n                <span>\n                    <div>{'u.location.country'}</div>\n                    <div>{'u.location.city'}</div>\n                </span>\n            </span>\n            </div>\n    );\n};\n\nexport default User;","import React from 'react';\nimport style from \"./Users.module.css\";\nimport {UserType} from \"../../redux/store\";\nimport {NavLink} from \"react-router-dom\";\nimport Paginator from \"../common/Paginator/Paginator\";\nimport User from \"./User\";\n\ntype UsersComponentPropsType = {\n    onPageChanged: (page: number) => void\n    totalItemsCount: number\n    portionSize: number\n    users: UserType[]\n    pageSize: number\n    currentPage: number\n    follow: (id: number) => void\n    unfollow: (id: number) => void\n    followingInProgress: number[]\n    unfollowUser: (userId: number) => void\n    followUser: (userId: number) => void\n}\nconst Users = (props: UsersComponentPropsType) => {\n\n    return (\n        <div>\n            <Paginator onPageChanged={props.onPageChanged}\n                       totalItemsCount={props.totalItemsCount}\n                       pageSize={props.pageSize}\n                       currentPage={props.currentPage}\n                       portionSize={props.portionSize}/>\n\n            {props.users.map(u => <User key={u.id}\n                                        user={u}\n                                        unfollowUser={props.unfollowUser}\n                                        followUser={props.followUser}\n                                        followingInProgress={props.followingInProgress}/>)}\n\n        </div>\n    );\n}\n\nexport default Users;","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = 'NOT_FOUND'\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    if (resultEqualityCheck) {\r\n      const lastResultValue = lastResult?.deref() ?? lastResult\r\n      if (\r\n        lastResultValue != null &&\r\n        resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n      ) {\r\n        result = lastResultValue\r\n        resultsCount !== 0 && resultsCount--\r\n      }\r\n\r\n      const needsWeakRef =\r\n        (typeof result === 'object' && result !== null) ||\r\n        typeof result === 'function'\r\n      lastResult = needsWeakRef ? new Ref(result) : result\r\n    }\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <InputSelectors extends SelectorArray, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import {createSelector} from \"reselect\";\nimport {AppRootStateType} from \"./redux-store\";\n\nconst getUsersSelector = (state: AppRootStateType) => {\n    return state.usersPage.users\n}\nexport const getUsers = createSelector(getUsersSelector, (users) => {\n    return users.filter(u => true)\n})\n\nexport const getPageSize = (state: AppRootStateType) => {\n    return state.usersPage.pageSize\n}\nexport const getPortionSize = (state: AppRootStateType) => {\n    return state.usersPage.portionSize\n}\nexport const getTotalUsersCount = (state: AppRootStateType) => {\n    return state.usersPage.totalItemsCount\n}\nexport const getCurrentPage = (state: AppRootStateType) => {\n    return state.usersPage.currentPage\n}\nexport const getIsFetching = (state: AppRootStateType) => {\n    return state.usersPage.isFetching\n}\nexport const getFollowingInProgress = (state: AppRootStateType) => {\n    return state.usersPage.followingInProgress\n}","import React from 'react';\nimport {connect} from \"react-redux\";\nimport {UserType} from \"../../redux/store\";\nimport {\n    followAC,\n    InitStateType,\n    setCurrentPageAC,\n    setUsersAC, toggleFollowingInProgressAC, toggleIsFetchingAC,\n    unfollowAC, getUsersTC, unfollowTC, followTC\n} from \"../../redux/users-reducer\";\nimport {AppRootStateType} from \"../../redux/redux-store\";\nimport Users from \"./Users\";\nimport Preloader from \"../common/preloader/Preloader\";\nimport {usersApi} from \"../../api/api\";\nimport {\n    getCurrentPage,\n    getFollowingInProgress,\n    getIsFetching,\n    getPageSize, getPortionSize,\n    getTotalUsersCount,\n    getUsers\n} from \"../../redux/users-selectors\";\n\n\ntype mapStateToPropsType = {\n    users: UserType[]\n    pageSize: number\n    portionSize: number\n    totalItemsCount: number\n    currentPage: number\n    isFetching: boolean\n    followingInProgress: number[]\n}\ntype mapDispatchToPropsType = {\n    follow: (userId: number) => void\n    unfollow: (userId: number) => void\n    setUsers: (users: UserType[]) => void\n    setCurrentPage: (currentPage: number) => void\n    toggleFollowingInProgress: (isFetching: boolean, userId: number) => void\n    getUsers: (currentPage: number, pageSize: number) => void\n    unfollowUser: (userId: number) => void\n    followUser: (userId: number) => void\n}\n\nexport type UsersMapPropsType = mapStateToPropsType & mapDispatchToPropsType\n\nclass UsersClass extends React.Component<UsersMapPropsType> {\n    componentDidMount() {\n        const {currentPage, pageSize} = this.props\n        this.props.getUsers(currentPage, pageSize)\n    }\n\n    onPageChanged = (pageNumber: number)=> {\n        const {pageSize} = this.props\n        this.props.getUsers(pageNumber, pageSize)\n    }\n\n    render() {\n        return <>\n            {this.props.isFetching\n                ? <Preloader/>\n                : null\n            }\n            <Users totalItemsCount={this.props.totalItemsCount}\n                   onPageChanged={this.onPageChanged}\n                   users={this.props.users}\n                   pageSize={this.props.pageSize}\n                   currentPage={this.props.currentPage}\n                   follow={this.props.follow}\n                   unfollow={this.props.unfollow}\n                   followingInProgress={this.props.followingInProgress}\n                   unfollowUser={this.props.unfollowUser}\n                   followUser={this.props.followUser}\n                   portionSize={this.props.portionSize}\n            />\n        </>\n    }\n}\n\nconst mapStateToProps = (state: AppRootStateType): mapStateToPropsType => {\n    return {\n        users: getUsers(state),\n        pageSize: getPageSize(state),\n        totalItemsCount: getTotalUsersCount(state),\n        currentPage: getCurrentPage(state),\n        isFetching: getIsFetching(state),\n        followingInProgress: getFollowingInProgress(state),\n        portionSize: getPortionSize(state)\n    }\n}\n// const mapDispatchToProps = (dispatch: (action: unfollowActionType | followActionType | setUsersActionType | setCurrentPageActionType | setTotalUsersCountActionType | toggleIsFetchingActionType) => void): mapDispatchToPropsType => {\n//     return {\n//         follow: (userId: number) => {\n//             dispatch(followAC(userId))\n//         },\n//         unfollow: (userId: number) => {\n//             dispatch(unfollowAC(userId))\n//         },\n//         setUsers: (users: UserType[]) => {\n//             dispatch(setUsersAC(users))\n//         },\n//         setCurrentPage: (currentPage: number) => {\n//             dispatch(setCurrentPageAC(currentPage))\n//         },\n//         setTotalUsersCount: (totalCount: number) => {\n//             dispatch(setTotalUsersCountAC(totalCount))\n//         },\n//         toggleIsFetching: (isFetching: boolean) => {\n//             dispatch(toggleIsFetchingAC(isFetching))\n//         }\n//     }\n// }\n\nconst MapObj = {\n    follow: followAC,\n    unfollow: unfollowAC,\n    setUsers: setUsersAC,\n    setCurrentPage: setCurrentPageAC,\n    toggleFollowingInProgress: toggleFollowingInProgressAC,\n    getUsers: getUsersTC,\n    unfollowUser: unfollowTC,\n    followUser: followTC\n}\n// export const UsersContainer = connect(mapStateToProps, mapDispatchToProps)(Users);\n// export const UsersContainer = connect(mapStateToProps, mapDispatchToProps)(UsersClass);\nconst UsersContainer = connect(mapStateToProps, MapObj)(UsersClass);\nexport default UsersContainer"],"names":["props","portionCount","Math","ceil","totalItemsCount","portionSize","useState","portionNumber","setPortionNumber","leftPortionPageNumber","rightPortionPageNumber","pagesCount","pageSize","pages","i","push","onClick","filter","p","map","page","onPageChanged","className","currentPage","style","v1","to","user","id","src","alt","followed","disabled","followingInProgress","some","unfollowUser","followUser","name","status","users","u","assertIsFunction","func","errorMessage","TypeError","ensureIsArray","item","Array","isArray","getDependencies","createSelectorArgs","dependencies","array","every","itemTypes","join","assertIsArrayOfFunctions","collectInputSelectorResults","inputSelectorArgs","inputSelectorResults","length","apply","Symbol","Object","getPrototypeOf","Ref","WeakRef","StrongRef","value","this","weakMapMemoize","lastResult","options","fnNode","s","v","o","resultEqualityCheck","resultsCount","memoized","cacheNode","arguments","l","arg","objectCache","WeakMap","objectNode","get","set","primitiveCache","Map","primitiveNode","result","terminatedNode","lastResultValue","deref","needsWeakRef","clearCache","resetResultsCount","createSelectorCreator","memoizeOrOptions","memoizeOptionsFromArgs","createSelectorCreatorOptions","memoize","memoizeOptions","createSelector","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","pop","combinedOptions","argsMemoize","argsMemoizeOptions","finalMemoizeOptions","devModeChecks","finalArgsMemoizeOptions","memoizedResultFunc","selector","assign","resetDependencyRecomputations","resetRecomputations","getUsers","state","usersPage","getPageSize","getPortionSize","getTotalUsersCount","getCurrentPage","getIsFetching","isFetching","getFollowingInProgress","UsersClass","pageNumber","Preloader","follow","unfollow","React","MapObj","followAC","unfollowAC","setUsers","setUsersAC","setCurrentPage","setCurrentPageAC","toggleFollowingInProgress","toggleFollowingInProgressAC","getUsersTC","unfollowTC","followTC","connect"],"sourceRoot":""}